<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title th:text="${'Spring Test Profiler Report'}">
    Spring Test Profiler Report</title>
  <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§ª</text></svg>">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style th:utext="${cssContent}"></style>
</head>
<body>
<div class="container">
  <h1 th:text="${'Spring Test Profiler Report'}">
    Spring Test Profiler Report</h1>
  <p>Understanding when and how many Spring ApplicationContexts are created in your test suite allows you to optimize
    build times by leveraging Spring TestContext's context caching feature, which reuses already started contexts.</p>
  <br/>
  <div class="timestamp" th:text="${'Generated at: ' + generatedAt}">Generated at: 2025-01-01 12:00:00</div>

  <!-- Theory Section Fragment -->
  <div th:replace="~{fragments/theory :: theory-section}"></div>

  <!-- Summary Section Fragment -->
  <div th:replace="~{fragments/summary :: summary-section(${executionTracker}, ${cacheStats})}"></div>

  <!-- Context Caching Statistics Fragment -->
  <div th:replace="~{fragments/caching :: caching-section(${cacheStats}, ${contextCacheTracker})}"></div>

  <!-- Context Comparison Visualizer Fragment -->
  <div th:replace="~{fragments/context-comparison :: context-comparison-section}"></div>

  <!-- Optimization Recommendations Fragment -->
  <!--  <div th:replace="~{fragments/optimization :: optimization-section(${optimizationStats})}"></div>-->

  <!-- Timeline Visualization Fragment -->
  <!--  <div th:replace="~{fragments/timeline :: timeline-section(${timelineData}, ${jsonHelper})}"></div>-->

  <!-- Context Configurations Fragment -->
  <div th:replace="~{fragments/configurations :: configurations-section}"></div>

  <!-- Test Execution Details Fragment -->
  <div th:replace="~{fragments/test-execution :: test-execution-section(${executionTracker})}"></div>

</div>

<!-- Footer -->
<footer class="footer">
  <div class="footer-content">
    <p>
      Get help with optimizing your Spring Boot test suite at
      <a href="https://pragmatech.digital" target="_blank" rel="noopener noreferrer">
        PragmaTech GmbH
      </a>
    </p>
    <p>
      Generated on <span th:text="${generatedAt}">2025-01-01 12:00:00</span>
      by <strong>Spring Test Profiler</strong>
      <span th:text="${extensionVersion}">v0.0.1-SNAPSHOT</span>
    </p>
    <p>
      <a href="https://github.com/PragmaTech-GmbH/spring-test-profiler" target="_blank"
         rel="noopener noreferrer">GitHub</a>
      |
      <a href="https://pragmatech.digital/products/" target="_blank" rel="noopener noreferrer">Documentation</a>
      |
      <a href="https://github.com/PragmaTech-GmbH/spring-test-profiler/issues" target="_blank"
         rel="noopener noreferrer">Submit a Bug or Feature Request</a>
    </p>
  </div>
</footer>

<script type="application/json" id="context-statistics-json" th:utext="${contextStatisticsJson}">[]</script>
<script>
  // Initialize empty context statistics (will be populated by ContextComparator initialization)
  window.contextStatistics = [];

  function toggleClass(element) {
    const methods = element.nextElementSibling;
    methods.classList.toggle('show');
  }

  function toggleTheorySection() {
    const content = document.getElementById('theory-content');
    const icon = document.getElementById('theory-toggle-icon');

    if (content.style.display === 'none') {
      content.style.display = 'block';
      icon.textContent = 'â–¼';
      icon.classList.add('expanded');
    } else {
      content.style.display = 'none';
      icon.textContent = 'â–¶';
      icon.classList.remove('expanded');
    }
  }

  /*<![CDATA[*/
  // Context Comparison Visualizer using D3.js
  class ContextComparator {
    constructor() {
      this.contextData = window.contextStatistics || [];
      this.selectedContextA = null;
      this.selectedContextB = null;
      this.init();
    }

    init() {
      this.populateDropdowns();
      this.bindEvents();
      this.preselectDefaultContexts();
    }

    populateDropdowns() {
      const contextASelect = document.getElementById('context-a-select');
      const contextBSelect = document.getElementById('context-b-select');

      if (!contextASelect || !contextBSelect) return;

      this.contextData.forEach(context => {
        const optionA = document.createElement('option');
        optionA.value = context.contextKey;
        optionA.textContent = `${context.contextKey} (${context.numberOfBeans} beans, ${context.testClasses.length} classes)`;
        contextASelect.appendChild(optionA);

        const optionB = document.createElement('option');
        optionB.value = context.contextKey;
        optionB.textContent = `${context.contextKey} (${context.numberOfBeans} beans, ${context.testClasses.length} classes)`;
        contextBSelect.appendChild(optionB);
      });
    }

    preselectDefaultContexts() {
      if (this.contextData.length >= 2) {
        const contextASelect = document.getElementById('context-a-select');
        const contextBSelect = document.getElementById('context-b-select');

        if (contextASelect && contextBSelect) {
          // Select first context for A
          contextASelect.value = this.contextData[0].contextKey;
          this.selectedContextA = this.contextData[0];

          // Select second context for B
          contextBSelect.value = this.contextData[1].contextKey;
          this.selectedContextB = this.contextData[1];

          // Update compare button state and trigger comparison
          this.updateCompareButton();
          this.compareContexts();
        }
      }
    }

    bindEvents() {
      const contextASelect = document.getElementById('context-a-select');
      const contextBSelect = document.getElementById('context-b-select');
      const compareBtn = document.getElementById('compare-contexts-btn');

      if (!contextASelect || !contextBSelect || !compareBtn) return;

      contextASelect.addEventListener('change', (e) => {
        if (e.target.value) {
          this.selectedContextA = this.contextData.find(ctx => ctx.contextKey === e.target.value);
        } else {
          this.selectedContextA = null;
        }
        this.updateCompareButton();
      });

      contextBSelect.addEventListener('change', (e) => {
        if (e.target.value) {
          this.selectedContextB = this.contextData.find(ctx => ctx.contextKey === e.target.value);
        } else {
          this.selectedContextB = null;
        }
        this.updateCompareButton();
      });

      compareBtn.addEventListener('click', (e) => {
        e.preventDefault();
        if (!compareBtn.disabled) {
          this.compareContexts();
        }
      });
    }

    updateCompareButton() {
      const compareBtn = document.getElementById('compare-contexts-btn');
      if (!compareBtn) return;

      const canCompare = this.selectedContextA && this.selectedContextB &&
                        this.selectedContextA.contextKey !== this.selectedContextB.contextKey;

      compareBtn.disabled = !canCompare;

      // Debug logging
      console.log('Compare button update:', {
        selectedContextA: this.selectedContextA?.contextKey,
        selectedContextB: this.selectedContextB?.contextKey,
        canCompare: canCompare,
        disabled: compareBtn.disabled
      });
    }

    compareContexts() {
      console.log('compareContexts called:', {
        selectedContextA: this.selectedContextA?.contextKey,
        selectedContextB: this.selectedContextB?.contextKey
      });

      if (!this.selectedContextA || !this.selectedContextB) {
        console.log('Cannot compare: missing context selection');
        return;
      }

      const legend = document.getElementById('context-comparison-legend');
      if (legend) {
        legend.style.display = 'flex';
      }

      this.renderComparison();
    }

    renderComparison() {
      const container = d3.select('#context-comparison-visualization');
      container.selectAll('*').remove();

      const width = 1000;
      const height = 600;
      const contextWidth = 400;
      const contextHeight = 400;

      const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height);

      // Add title
      svg.append('text')
        .attr('x', width / 2)
        .attr('y', 30)
        .attr('text-anchor', 'middle')
        .attr('class', 'comparison-title')
        .style('font-size', '20px')
        .style('font-weight', 'bold')
        .text('Spring Test Context Comparison');

      // Context A
      this.renderContext(svg, this.selectedContextA, 50, 80, 'Test Context A');

      // Context B
      this.renderContext(svg, this.selectedContextB, 550, 80, 'Test Context B');
    }

    renderContext(svg, context, x, y, title) {
      const group = svg.append('g').attr('transform', `translate(${x}, ${y})`);

      // Title
      group.append('text')
        .attr('x', 200)
        .attr('y', 0)
        .attr('text-anchor', 'middle')
        .style('font-size', '18px')
        .style('font-weight', 'bold')
        .text(title);

      // Central beans circle
      const centerX = 200;
      const centerY = 200;
      const centralRadius = 80;

      group.append('circle')
        .attr('cx', centerX)
        .attr('cy', centerY)
        .attr('r', centralRadius)
        .attr('fill', '#3498db')
        .attr('stroke', '#2980b9')
        .attr('stroke-width', 2);

      group.append('text')
        .attr('x', centerX)
        .attr('y', centerY - 10)
        .attr('text-anchor', 'middle')
        .attr('fill', 'white')
        .style('font-size', '16px')
        .style('font-weight', 'bold')
        .text('Beans');

      group.append('text')
        .attr('x', centerX)
        .attr('y', centerY + 10)
        .attr('text-anchor', 'middle')
        .attr('fill', 'white')
        .style('font-size', '18px')
        .style('font-weight', 'bold')
        .text(`(${context.numberOfBeans})`);

      // Configuration features
      const features = this.getContextFeatures(context);
      const angleStep = (2 * Math.PI) / features.length;
      const satelliteRadius = 140;

      features.forEach((feature, i) => {
        const angle = i * angleStep - Math.PI / 2;
        const featureX = centerX + Math.cos(angle) * satelliteRadius;
        const featureY = centerY + Math.sin(angle) * satelliteRadius;

        const featureGroup = group.append('g')
          .attr('transform', `translate(${featureX}, ${featureY})`);

        // Feature circle
        featureGroup.append('circle')
          .attr('cx', 0)
          .attr('cy', 0)
          .attr('r', 25)
          .attr('fill', this.getFeatureColor(feature))
          .attr('stroke', '#34495e')
          .attr('stroke-width', 1)
          .style('cursor', 'pointer')
          .on('mouseover', (event) => this.showTooltip(event, feature, context))
          .on('mouseout', () => this.hideTooltip());

        // Feature label
        featureGroup.append('text')
          .attr('x', 0)
          .attr('y', 35)
          .attr('text-anchor', 'middle')
          .style('font-size', '10px')
          .style('font-weight', 'bold')
          .text(feature.name);

        // Connecting line
        group.append('line')
          .attr('x1', centerX + Math.cos(angle) * (centralRadius + 5))
          .attr('y1', centerY + Math.sin(angle) * (centralRadius + 5))
          .attr('x2', featureX - Math.cos(angle) * 30)
          .attr('y2', featureY - Math.sin(angle) * 30)
          .attr('stroke', '#bdc3c7')
          .attr('stroke-width', 2)
          .attr('stroke-dasharray', '5,5');
      });
    }

    getContextFeatures(context) {
      const config = context.contextConfiguration;
      return [
        { name: 'Locations', value: config.locations, key: 'locations' },
        { name: 'Classes', value: config.classes, key: 'classes' },
        { name: 'Context Initializer Classes', value: config.contextInitializerClasses, key: 'contextInitializerClasses' },
        { name: 'Active Profiles', value: config.activeProfiles, key: 'activeProfiles' },
        { name: 'Property Source Locations', value: config.propertySourceLocations, key: 'propertySourceLocations' },
        { name: 'Context Customizers', value: config.contextCustomizers, key: 'contextCustomizers' },
        { name: 'Context Loader', value: [config.contextLoader], key: 'contextLoader' },
        { name: 'Parent', value: config.parent ? [config.parent] : [], key: 'parent' }
      ];
    }

    getFeatureColor(feature) {
      if (!this.selectedContextA || !this.selectedContextB) return '#95a5a6';

      const configA = this.selectedContextA.contextConfiguration;
      const configB = this.selectedContextB.contextConfiguration;

      const valueA = this.getFeatureValue(configA, feature.key);
      const valueB = this.getFeatureValue(configB, feature.key);

      const arrayA = Array.isArray(valueA) ? valueA : [valueA];
      const arrayB = Array.isArray(valueB) ? valueB : [valueB];

      if (this.arraysEqual(arrayA, arrayB)) {
        return '#27ae60'; // Same - green
      } else {
        return '#e74c3c'; // Different - red
      }
    }

    getFeatureValue(config, key) {
      switch(key) {
        case 'contextLoader': return config.contextLoader;
        case 'parent': return config.parent;
        default: return config[key] || [];
      }
    }

    arraysEqual(a, b) {
      if (a.length !== b.length) return false;
      const sortedA = [...a].sort();
      const sortedB = [...b].sort();
      return sortedA.every((val, i) => val === sortedB[i]);
    }

    showTooltip(event, feature, context) {
      const tooltip = document.getElementById('context-comparison-tooltip');
      const tooltipContent = tooltip.querySelector('.tooltip-content');

      const otherContext = context === this.selectedContextA ? this.selectedContextB : this.selectedContextA;
      const valueA = this.getFeatureValue(this.selectedContextA.contextConfiguration, feature.key);
      const valueB = this.getFeatureValue(this.selectedContextB.contextConfiguration, feature.key);

      const arrayA = Array.isArray(valueA) ? valueA : [valueA];
      const arrayB = Array.isArray(valueB) ? valueB : [valueB];

      let content = `<strong>${feature.name}</strong><br/>`;

      if (this.arraysEqual(arrayA, arrayB)) {
        content += `<span style="color: #27ae60;">âœ“ Same configuration</span><br/>`;
        content += `Value: ${arrayA.length > 0 ? arrayA.join(', ') : 'None'}`;
      } else {
        content += `<span style="color: #e74c3c;">âœ— Different values</span><br/>`;
        content += `Context A: ${arrayA.length > 0 ? arrayA.join(', ') : 'None'}<br/>`;
        content += `Context B: ${arrayB.length > 0 ? arrayB.join(', ') : 'None'}`;
      }

      tooltipContent.innerHTML = content;

      tooltip.style.display = 'block';
      tooltip.style.left = (event.pageX + 10) + 'px';
      tooltip.style.top = (event.pageY - 10) + 'px';
    }

    hideTooltip() {
      document.getElementById('context-comparison-tooltip').style.display = 'none';
    }
  }

  // Initialize context comparator when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    // Ensure JSON is parsed first
    try {
      const jsonScript = document.getElementById('context-statistics-json');
      if (jsonScript) {
        window.contextStatistics = JSON.parse(jsonScript.textContent || '[]');
      }
    } catch (e) {
      console.error('Failed to parse context statistics JSON:', e);
      window.contextStatistics = [];
    }

    if (window.contextStatistics && window.contextStatistics.length > 0) {
      new ContextComparator();
    }
  });
  /*]]>*/
</script>
</body>
</html>
